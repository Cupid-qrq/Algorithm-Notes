#include <bits/stdc++.h>
using namespace std;

// tag: 状压dp,位运算，O(n^2 * 2^n)
// 2025.12.24

const double inf = 1e18;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    vector<double> x(n), y(n), dist_s(n); // dist_s[i]表示从原点到第i个点的距离
    vector<vector<double>> dist_each(n, vector<double>(n)); // 各点间距离

    // 计算从原点到各点的距离
    for (int i = 0; i < n; i++) {
        cin >> x[i] >> y[i];
        dist_s[i] = sqrt(x[i] * x[i] + y[i] * y[i]);
    }
    // 预处理各点间距离
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j)
                dist_each[i][j] = 0;
            else {
                double dx = x[i] - x[j], dy = y[i] - y[j];
                dist_each[i][j] = sqrt(dx * dx + dy * dy);
            }
        }
    }

    // 状压dp, all表示状态总数, dp[set][i]表示访问状态为set且最后访问点为i的最短距离
    // set维护的是访问过的集合，第j位为1表示第j个点被访问过
    int all = 1 << n;
    vector<vector<double>> dp(all, vector<double>(n, inf));
    // 初始化从原点出发到各点的距离
    for (int i = 0; i < n; i++) {
        dp[1 << i][i] = dist_s[i];
    }

    // 枚举所有状态
    for (int set = 1; set < all; set++) {
        for (int t = 0; t < n; t++) { // 从当前状态中访问过的点枚举当前点
            if (!((1 << t) & set)) continue; // 当前点t不在访问集合中，跳过

            for (int j = 0; j < n; j++) { // 枚举下一个要访问的点
                if ((1 << j) & set) continue; // j已经在访问集合中，跳过
                int newset = set | (1 << j);  // 标记j为已访问
                // 状态转移
                dp[newset][j] = min(dp[newset][j], dp[set][t] + dist_each[t][j]);
            }
        }
    }

    double ans = inf;
    for (int i = 0; i < n; i++) {
        // 答案就是各个点作为最后访问点的最小值
        ans = min(ans, dp[all - 1][i]);
    }
    cout << fixed << setprecision(2) << ans;
    return 0;
}

/*
2.1题目分析
难度：普及+/提高
标签：动态规划DP，深度优先搜索，剪枝，记忆化搜索，状态压缩DP
题目描述：
房间里放着n块奶酪。一只小老鼠要把它们都吃掉，问至少要跑多少距离？老鼠一开始在 (0,0) 点处。
输入格式：
第一行有一个整数，表示奶酪的数量 n。
第 2 到第 (n+1) 行，每行两个实数，第 (i+1) 行的实数分别表示第 i 块奶酪的横纵坐标 xi，yi
输出格式：
输出一行一个实数，表示要跑的最少距离，保留 2 位小数。

首先，对于这道题目，我们可以将其抽象为一个图论问题。每块奶酪可以看作图中的一个节点，节点之间的边权则是它们之间的欧几里得距离。小老鼠需要从起点(0,0)出发，访问所有节点（奶酪）一次，并且要求路径长度最短。不难发现，小老鼠的移动路径和吃奶酪的顺序与最终的总距离密切相关。第一眼看上去，很容易想到使用暴力搜索的方法，枚举所有可能的访问顺序，然后计算每种顺序对应的路径长度，最后取最小值。然而，这种方法的时间复杂度是O(n!)，当n较大时，计算量将变得非常庞大，难以在合理时间内完成计算。
如果考虑贪心算法，因为我们想要尽可能减小总路径长度，那每一步都选择距离当前位置最近的奶酪似乎是一个不错的策略。然而，这显然是不可取的，因为贪心算法只考虑了当前路径长度增量最小的选择，而不考虑后续路径的影响，如果当前选择了一个看似最近的奶酪，可能会导致后续必须绕远路去吃其他奶酪，从而增加总路径长度。因此，局部最优并不能够保证全局最优，所以贪心算法并不能保证找到全局最优解。

实际上，这个问题可以看作是旅行商问题（Traveling Salesman Problem,TSP）。旅行商问题是一个经典的NP难题，要求在给定的一组城市中找到一条最短路径，使得每个城市恰好访问一次并返回起点。对于这个问题，理论上没有已知的多项式时间解法。然而，由于题目中奶酪的数量n相对较小（通常在20以下），我们可以采用动态规划结合状态压缩的方法来求解，从而在合理的时间内得到最优解。通过分析，我们可以确定问题具有最优子结构和重叠子问题的性质。具体来说，假设我们已经计算出了访问某一子集奶酪的最短路径长度，那么当我们需要访问一个新的奶酪时，我们只需考虑从已经访问过的奶酪中选择一个作为前驱节点，然后加上从该节点到新奶酪的距离。这样，我们可以通过递推的方式逐步构建出访问所有奶酪的最短路径。但是，如果直接使用二维数组来存储状态，空间复杂度将会非常高，尤其是当奶酪数量较多时。因此，我们可以使用状压DP的方法来优化。下面就要介绍DP+状态压缩的设计和实现思路。

2.2 算法设计
首先，我们需要明确核心状态和转移方式。在本题中，当小老鼠已经访问了一部分奶酪之后，问题在于如何选择下一个前往的奶酪，这一过程会受到已经访问过的奶酪的集合的影响。如何表示这个集合呢？如果简单的使用n维数组来表示每个奶酪是否被访问过，那么空间复杂度为O(2^n)，显然这是不可接受的。为了解决这个问题，我们引入状态压缩的概念。具体来说，我们可以使用一个整数的二进制位来表示奶酪的访问状态。例如，如果有5块奶酪，那么一个5位的二进制数00011就表示前两块奶酪已经被访问过，而后三块奶酪尚未被访问。这样，我们就可以将访问状态压缩到一个整数中，从而大大减少空间复杂度。
通过这样的表示，我们很容易得到几个描述状态的关键操作：
1.所有奶酪构成的集合为(1<<n)-1，即二进制的111...1，共n位，表示所有奶酪都被访问过。
2.当前访问状态为set时，表示已经访问过的奶酪集合。
3.判断第i块奶酪是否被访问过，可以通过(set & (1<<i))来实现。如果结果不为0，说明第i块奶酪已经被访问过。
4. 将第j块奶酪标记为已访问，可以通过set | (1<<j)来实现，得到一个新的状态newset。

基于上述状态表示，我们可以定义动态规划的状态转移方程。设dp[set][i]表示在访问状态为set且最后访问点为i的最短距离。那么，对于每一个未被访问的奶酪j，我们可以通过以下方式更新状态：
dp[newset][j] = min(dp[newset][j], dp[set][i] + dist(i, j))
也就是从当前状态set出发，选择一个已经访问过的奶酪i作为前驱节点，然后加上从i到j的距离，更新访问状态newset下以j为最后访问点的最短距离。
通过上述状态转移方程，我们可以逐步构建出访问所有奶酪的最短路径。最终，我们需要遍历所有以不同奶酪为最后访问点的状态，找到最小的路径长度作为答案。
因此整个算法的实现只需要遍历所有可能的访问状态，然后遍历当前状态下的所有已访问奶酪，作为当前小老鼠所在位置，接着遍历所有未被访问的奶酪，作为下一个要访问的奶酪，进行状态转移和更新。最终，我们可以得到访问所有奶酪的最短路径长度。

最后是一些实现的细节：
1.距离的计算：由于题目中给出的奶酪坐标是实数，因此我们需要使用浮点数类型（如double）来存储距离，并使用sqrt函数计算欧几里得距离。
2.初始化：在动态规划的初始化阶段，我们需要将从起点(0,0)到每块奶酪的距离作为初始状态进行设置。
3.由于在DP过程中会进行大量的任意两点间距离计算，所以我们在一开始预先计算并存储这些距离，以提高效率。


2.3 性能分析
每次状态转移时，我们需要遍历当前状态下的所有已访问奶酪和所有未被访问的奶酪。假设当前状态set中有k块奶酪已经被访问，那么在进行状态转移时，我们需要进行k*(n-k)次操作。对于所有可能的状态set，总共有2^n种状态，而每种状态下k的取值范围是0到n。因此，整体时间复杂度可以表示为O(n^2 * 2^n)。虽然这个复杂度看起来较高，但由于n通常较小（如20以下），在实际运行中仍然是可行的。

空间复杂度方面，我们需要存储一个大小为O(n * 2^n)的DP表，用于记录每个状态下的最短路径长度。此外，我们还需要存储距离矩阵，大小为O(n^2)。因此，整体空间复杂度为O(n * 2^n)，在n较小的情况下也是可以接受的。

2.4 运行测试



*/